# jas5469
###### \main\java\seedu\address\commons\events\ui\GroupPanelSelectionChangedEvent.java
``` java
package seedu.address.commons.events.ui;

import seedu.address.commons.events.BaseEvent;
import seedu.address.ui.GroupCard;

/**
 * Represents a selection change in the Group List Panel
 */
public class GroupPanelSelectionChangedEvent extends BaseEvent {


    private final GroupCard newSelection;

    public GroupPanelSelectionChangedEvent(GroupCard newSelection) {
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \main\java\seedu\address\logic\commands\AddGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;

/**
 * Adds a group to the address book.
 */
public class AddGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "addGroup";
    public static final String COMMAND_ALIAS = "aG";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a group to the address book. "
            + "Parameters: "
            + "GROUP NAME "
            + "Example: " + COMMAND_WORD + " "
            + "CS1010 project";

    public static final String MESSAGE_SUCCESS = "New group added: %1$s";
    public static final String MESSAGE_DUPLICATE_GROUP = "This group already exists in the address book";

    private final Group addGroup;

    /**
     * Creates an AddGroupCommand to add the specified {@code Group}
     */
    public AddGroupCommand(Group group) {
        requireNonNull(group);
        addGroup = group;
    }

    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);
        try {
            model.addGroup(addGroup);
            return new CommandResult(String.format(MESSAGE_SUCCESS, addGroup));
        } catch (DuplicateGroupException e) {
            throw new CommandException(MESSAGE_DUPLICATE_GROUP);
        }

    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddGroupCommand // instanceof handles nulls
                && addGroup.equals(((AddGroupCommand) other).addGroup));
    }
}
```
###### \main\java\seedu\address\logic\commands\AddMemberToGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.DuplicatePersonException;

/**
 * Finds a person by index  add him to a specific group in Fastis .
 * Keyword matching is case sensitive.
 */
public class AddMemberToGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "addGroupMember";
    public static final String COMMAND_ALIAS = "aGM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds person via index on the most recent list "
            + "and add to group that contain the specified keywords (case-sensitive).\n"
            + "Parameters: INDEX (must be a positive integer) g/GroupName(Must exist) "
            + "Example: " + COMMAND_WORD + " 1 "
            + PREFIX_GROUP + "CS1010";

    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";
    public static final String MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS = "%1$s added to group %2$s";
    public static final String MESSAGE_DUPLICATE_PERSON = "Person already in Group";
    public static final String MESSAGE_GROUP_NOT_FOUND = "No such Group in Fastis";
    public static final String MESSAGE_DUPLICATE_GROUP = "Group already in Group";

    private Index index;
    private Person personToAdd;
    private Group groupToAdd;
    private Group groupAdded;
    private List<Group> groupList;

    public AddMemberToGroupCommand(Index index, Group groupToAdd) {
        requireNonNull(index);
        this.index = index;
        this.groupToAdd = groupToAdd;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);

        for (Group group : groupList) {
            if (groupToAdd.getInformation().equals(group.getInformation())) {
                try {
                    groupAdded = new Group(group.getInformation(), group.getPersonList());
                    groupAdded.addPerson(personToAdd);
                    model.updateGroup(group, groupAdded);
                } catch (DuplicatePersonException e) {
                    throw new CommandException(MESSAGE_DUPLICATE_PERSON);
                } catch (DuplicateGroupException e) {
                    throw new CommandException(MESSAGE_DUPLICATE_GROUP);
                } catch (GroupNotFoundException e) {
                    throw new CommandException(MESSAGE_GROUP_NOT_FOUND);
                }
            }
        }
        return new CommandResult(String.format(MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS, personToAdd.getName(),
                groupToAdd.getInformation().toString()));
    }

    @Override
    protected void preprocessUndoableCommand() throws CommandException {
        List<Person> lastShownList = model.getFilteredPersonList();
        groupList = model.getFilteredGroupList();
        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToAdd.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            personToAdd = lastShownList.get(index.getZeroBased());
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddMemberToGroupCommand // instanceof handles nulls
                && groupToAdd.equals(((AddMemberToGroupCommand) other).groupToAdd));
    }


}
```
###### \main\java\seedu\address\logic\commands\DeleteGroupCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;
import java.util.Objects;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.exceptions.GroupNotFoundException;

/**
 * Deletes a group identified using it's last displayed index from the address book.
 */
public class DeleteGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "deleteGroup";
    public static final String COMMAND_ALIAS = "dG";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the group identified by the group Name used.\n"
            + "Parameters: GroupName(Must exist) KEYWORD ...\n"
            + "CS1010";

    public static final String MESSAGE_DELETE_GROUP_SUCCESS = "Deleted group: %1$s";
    public static final String MESSAGE_NO_SUCH_GROUP = "Group not found";

    private final Information groupName;

    private Group groupToDelete;

    public DeleteGroupCommand(Information groupName) {
        this.groupName = groupName;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        groupToDelete = new Group(groupName);
        List<Group> groupList = model.getFilteredGroupList();
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToDelete.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            for (Group group : groupList) {
                if (groupName.equals(group.getInformation())) {
                    groupToDelete = group;
                }
            }
            try {
                model.deleteGroup(groupToDelete);
            } catch (GroupNotFoundException gnfe) {
                throw new CommandException(String.format(MESSAGE_NO_SUCH_GROUP,
                        groupName.toString()));
            }

            return new CommandResult(String.format(MESSAGE_DELETE_GROUP_SUCCESS,
                    groupToDelete.getInformation().toString()));

        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DeleteGroupCommand // instanceof handles nulls
                && this.groupName.equals(((DeleteGroupCommand) other).groupName) // state check
                && Objects.equals(this.groupToDelete, ((DeleteGroupCommand) other).groupToDelete));
    }
}
```
###### \main\java\seedu\address\logic\commands\DeleteMemberFromGroupCommand.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.PersonNotFoundException;

/**
 * Finds by index and delete person in a group that exist in  Fastis .
 * Keyword matching is case sensitive.
 */
public class DeleteMemberFromGroupCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "deleteGroupMember";
    public static final String COMMAND_ALIAS = "dGM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds person via index on the most recent list "
            + "and delete from group that contain the specified keywords (case-sensitive).\n"
            + "Parameters: INDEX (must be a positive integer) g/GroupName(Must exist) "
            + "Example: " + COMMAND_WORD + " 1 "
            + PREFIX_GROUP + "CS1010";

    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";
    public static final String MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS = "%1$s deleted from group %2$s";
    public static final String MESSAGE_GROUP_NOT_FOUND = "No such Group in Fastis";
    public static final String MESSAGE_DUPLICATE_GROUP = "Group already in Group";
    public static final String MESSAGE_PERSON_NOT_FOUND = "No such Person in Group";

    private Index index;
    private Person personToDelete;
    private Group groupToDelete;
    private Group groupInvolved;
    private List<Group> groupList;

    public DeleteMemberFromGroupCommand(Index index, Group groupToDelete) {
        requireNonNull(index);
        this.index = index;
        this.groupToDelete = groupToDelete;
    }


    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);

        for (Group group : groupList) {
            if (groupToDelete.getInformation().equals(group.getInformation())) {
                try {
                    groupInvolved = new Group(group.getInformation(), group.getPersonList());
                    groupInvolved.removePerson(personToDelete);
                    model.updateGroup(group, groupInvolved);
                } catch (DuplicateGroupException e) {
                    throw new CommandException(MESSAGE_DUPLICATE_GROUP);
                } catch (GroupNotFoundException e) {
                    throw new CommandException(MESSAGE_GROUP_NOT_FOUND);
                } catch (PersonNotFoundException e) {
                    throw new CommandException(MESSAGE_PERSON_NOT_FOUND);
                }
            }
        }
        return new CommandResult(String.format(MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS, personToDelete.getName(),
                groupToDelete.getInformation().toString()));
    }

    @Override
    protected void preprocessUndoableCommand() throws CommandException {
        List<Person> lastShownList = model.getFilteredPersonList();
        groupList = model.getFilteredGroupList();
        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToDelete.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            personToDelete = lastShownList.get(index.getZeroBased());
        }

    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof seedu.address.logic.commands
                .DeleteMemberFromGroupCommand // instanceof handles nulls
                && groupToDelete.equals(((seedu.address.logic.commands
                .DeleteMemberFromGroupCommand) other).groupToDelete));
    }


}
```
###### \main\java\seedu\address\logic\commands\ListGroupMembersCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.group.Group;
import seedu.address.model.group.MembersInGroupPredicate;

/**
 * Lists all persons in the address book to the user under the same group.
 */
public class ListGroupMembersCommand extends Command {


    public static final String COMMAND_WORD = "listGroupMembers";
    public static final String COMMAND_ALIAS = "lGM";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all persons whose Group contain any of "
        + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
        + "Parameters: KEYWORD \n"
        + "Example: " + COMMAND_WORD + " CS1010";
    public static final String MESSAGE_SUCCESS = "Listed all persons under group %1$s";
    public static final String MESSAGE_NO_SUCH_GROUP = "No such group exist.";

    private final MembersInGroupPredicate predicate;
    private Group groupToList;
    private Group groupToBeListed;

    public ListGroupMembersCommand(MembersInGroupPredicate predicate, Group groupToList) {
        this.predicate = predicate;
        this.groupToList = groupToList;
    }

    @Override
    public CommandResult execute() throws CommandException {

        List<Group> groupList = model.getFilteredGroupList();
        boolean contains = new Boolean(Boolean.FALSE);
        for (Group g : groupList) {
            if (g.getInformation().equals(groupToList.getInformation())) {
                contains = true;
            }
        }
        if (contains == false) {
            throw new CommandException(MESSAGE_NO_SUCH_GROUP);
        } else {
            for (Group group : groupList) {
                if (groupToList.getInformation().equals(group.getInformation())) {
                    groupToBeListed = group;
                }
            }
            MembersInGroupPredicate predicateCurr = new MembersInGroupPredicate(groupToBeListed);
            model.updateFilteredPersonList(predicateCurr);
            return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredPersonList().size()));

        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof ListGroupMembersCommand // instanceof handles nulls
            && this.predicate.equals(((ListGroupMembersCommand) other).predicate)); // state check
    }
}

```
###### \main\java\seedu\address\logic\commands\ListTagMembersCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.model.person.TagContainKeywordsPredicate;

/**
 * Finds and lists all persons in address book whose tag name is of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class ListTagMembersCommand extends Command {

    public static final String COMMAND_WORD = "listTagMembers";
    public static final String COMMAND_ALIAS = "lTM";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all persons whose tags contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " CS1010";


    private final TagContainKeywordsPredicate predicate;

    public ListTagMembersCommand(TagContainKeywordsPredicate predicate) {
        this.predicate = predicate;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredPersonList(predicate);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredPersonList().size()));
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ListTagMembersCommand // instanceof handles nulls
                && this.predicate.equals(((ListTagMembersCommand) other).predicate)); // state check
    }
}
```
###### \main\java\seedu\address\logic\parser\AddGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.person.UniquePersonList;


/**
 * Parses input arguments and creates a new AddGroupCommand object
 */
public class AddGroupCommandParser implements Parser<AddGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the AddGroupCommand
     * and returns an AddGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddGroupCommand parse(String args) throws ParseException {

        if (args.trim().isEmpty()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddGroupCommand.MESSAGE_USAGE));
        }

        try {
            Information information = ParserUtil.parseInformation(args);
            UniquePersonList personList = new UniquePersonList();
            Group group = new Group(information);

            return new AddGroupCommand(group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }
}
```
###### \main\java\seedu\address\logic\parser\AddMemberToGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.stream.Stream;

import seedu.address.commons.core.index.Index;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddMemberToGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new AddMemberToGroupCommand object
 */
public class AddMemberToGroupCommandParser implements Parser<AddMemberToGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the AddMemberToGroupCommand
     * and returns an AddMemberToGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddMemberToGroupCommand parse(String args) throws ParseException {

        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_GROUP);

        if (!arePrefixesPresent(argMultimap, PREFIX_GROUP)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    AddMemberToGroupCommand.MESSAGE_USAGE));
        }

        try {
            Index index = ParserUtil.parseIndex(argMultimap.getPreamble());
            Information information = ParserUtil.parseInformation(argMultimap.getValue(PREFIX_GROUP).get());
            Group group = new Group(information);
            return new AddMemberToGroupCommand(index, group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }

}
```
###### \main\java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case AddGroupCommand.COMMAND_WORD:
        case AddGroupCommand.COMMAND_ALIAS:
            return new AddGroupCommandParser().parse(arguments);

        case AddMemberToGroupCommand.COMMAND_WORD:
        case AddMemberToGroupCommand.COMMAND_ALIAS:
            return new AddMemberToGroupCommandParser().parse(arguments);
```
###### \main\java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case DeleteGroupCommand.COMMAND_WORD:
        case DeleteGroupCommand.COMMAND_ALIAS:
            return new DeleteGroupCommandParser().parse(arguments);

        case DeleteMemberFromGroupCommand.COMMAND_WORD:
        case DeleteMemberFromGroupCommand.COMMAND_ALIAS:
            return new DeleteMemberFromGroupCommandParser().parse(arguments);
```
###### \main\java\seedu\address\logic\parser\AddressBookParser.java
``` java
        case ListGroupMembersCommand.COMMAND_WORD:
        case ListGroupMembersCommand.COMMAND_ALIAS:
            return new ListGroupMembersCommandParser().parse(arguments);

        case ListTagMembersCommand.COMMAND_WORD:
        case ListTagMembersCommand.COMMAND_ALIAS:
            return new ListTagMembersCommandParser().parse(arguments);
```
###### \main\java\seedu\address\logic\parser\DeleteGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.DeleteGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new DeleteGroupCommand object
 */
public class DeleteGroupCommandParser implements Parser<DeleteGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteGroupCommand
     * and returns an DeleteGroupCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public DeleteGroupCommand parse(String args) throws ParseException {


        try {
            Information information = ParserUtil.parseInformation(args);
            return new DeleteGroupCommand(information);
        } catch (IllegalValueException ive) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteGroupCommand.MESSAGE_USAGE));
        }

    }
}
```
###### \main\java\seedu\address\logic\parser\DeleteMemberFromGroupCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_GROUP;

import java.util.stream.Stream;

import seedu.address.commons.core.index.Index;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.DeleteMemberFromGroupCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;

/**
 * Parses input arguments and creates a new DeleteMemberFromGroupCommand object
 */
public class DeleteMemberFromGroupCommandParser implements Parser<DeleteMemberFromGroupCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteMemberFromGroupCommand
     * and returns an DeleteMemberFromGroupCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public DeleteMemberFromGroupCommand parse(String args) throws ParseException {

        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_GROUP);

        if (!arePrefixesPresent(argMultimap, PREFIX_GROUP)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    DeleteMemberFromGroupCommand.MESSAGE_USAGE));
        }

        try {
            Index index = ParserUtil.parseIndex(argMultimap.getPreamble());
            Information information = ParserUtil.parseInformation(argMultimap.getValue(PREFIX_GROUP).get());
            Group group = new Group(information);
            return new DeleteMemberFromGroupCommand(index, group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }

}
```
###### \main\java\seedu\address\logic\parser\ListGroupMembersCommandParser.java
``` java
package seedu.address.logic.parser;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.ListGroupMembersCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.MembersInGroupPredicate;

/**
 * Parses input arguments and creates a new ListGroupMembersCommand object
 */
public class ListGroupMembersCommandParser implements Parser<ListGroupMembersCommand> {


    /**
     * Parses the given {@code String} of arguments in the context of the ListGroupMembersCommand
     * and returns an ListGroupMembersCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public ListGroupMembersCommand parse(String args) throws ParseException {
        requireNonNull(args);

        if (args.isEmpty()) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListGroupMembersCommand.MESSAGE_USAGE));
        }
        try {
            Information information = ParserUtil.parseInformation(args);
            Group group = new Group(information);
            return new ListGroupMembersCommand(new MembersInGroupPredicate(group), group);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

}
```
###### \main\java\seedu\address\logic\parser\ListTagMembersCommandParser.java
``` java

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Arrays;

import seedu.address.logic.commands.ListTagMembersCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.person.TagContainKeywordsPredicate;

/**
 * Parses input arguments and creates a new ListTagMembersCommand object
 */
public class ListTagMembersCommandParser implements Parser<ListTagMembersCommand> {

    /**
     * Parses the given {@code String} of arguments in the context of the ListTagMembersCommand
     * and returns an ListTagMembersCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public ListTagMembersCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        if (trimmedArgs.isEmpty()) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListTagMembersCommand.MESSAGE_USAGE));
        }

        String[] nameKeywords = trimmedArgs.split("\\s+");

        return new ListTagMembersCommand(new TagContainKeywordsPredicate(Arrays.asList(nameKeywords)));
    }

}
```
###### \main\java\seedu\address\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code String content} into a {@code Content}.
     * Leading and trailing whitespaces will be trimmed.
     *
     * @throws IllegalValueException if the given {@code content} is invalid.
     */
    public static Information parseInformation(String information) throws IllegalValueException {
        requireNonNull(information);
        String trimmedInformation = information.trim();
        if (!Content.isValidContent(trimmedInformation)) {
            throw new IllegalValueException(Information.MESSAGE_INFORMATION_CONSTRAINTS);
        }
        return new Information(trimmedInformation);
    }

```
###### \main\java\seedu\address\model\AddressBook.java
``` java
    ////Group operation
    public void addGroup(Group group) throws DuplicateGroupException {
        groups.add(group);
    }

    /**
     * Removes {@code key} from this {@code AddressBook}.
     *
     * @throws ToDoNotFoundException if the {@code key} is not in this {@code AddressBook}.
     */
    public boolean removeGroup(Group key) throws GroupNotFoundException {
        if (groups.remove(key)) {
            return true;
        } else {
            throw new GroupNotFoundException();
        }
    }
```
###### \main\java\seedu\address\model\group\exceptions\DuplicateGroupException.java
``` java
package seedu.address.model.group.exceptions;

import seedu.address.commons.exceptions.DuplicateDataException;

/**
 * Signals that the operation will result in duplicate Group objects.
 */
public class DuplicateGroupException extends DuplicateDataException {
    public DuplicateGroupException() {
        super("Operation would result in duplicate groups");
    }
}
```
###### \main\java\seedu\address\model\group\exceptions\GroupNotFoundException.java
``` java

/**
 * Signals that the operation is unable to find the specified group.
 */
public class GroupNotFoundException extends Exception {}
```
###### \main\java\seedu\address\model\group\Group.java
``` java
package seedu.address.model.group;

import static seedu.address.commons.util.CollectionUtil.requireAllNonNull;

import java.util.Objects;

import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;
import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;

/**
 * Represents a Group in the address book.
 * Guarantees: details are present and not null, field values are validated, immutable.
 */
public class Group {

    private final Information information;
    private UniquePersonList personList;

    /**
     * Every field must be present and not null.
     */
    public Group(Information information) {
        requireAllNonNull(information);
        this.information = information;
        this.personList = new UniquePersonList();
    }
    /**
     * Every field must be present and not null.
     */
    public Group(Information information, UniquePersonList personList) {
        requireAllNonNull(information);
        this.information = new Information(information.value);
        this.personList = new UniquePersonList();
        this.personList.setPersons(personList);
    }

    public Information getInformation() {
        return information;
    }

    public UniquePersonList getPersonList() {
        return personList;
    }

```
###### \main\java\seedu\address\model\group\Group.java
``` java

    /**
     * Removes a person to the group's personList
     * @param toRemove The Person to remove.
     * @throws DuplicatePersonException
     */
    public void removePerson(Person toRemove) throws PersonNotFoundException {
        if (!getPersonList().contains(toRemove)) {
            throw new PersonNotFoundException();
        } else {
            this.personList.remove(toRemove);
        }

    }
    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (!(other instanceof Group)) {
            return false;
        }

        Group otherGroup = (Group) other;
        if (otherGroup.getInformation().equals(this.getInformation())
            && otherGroup.getPersonList().asObservableList().size() == this.getPersonList().asObservableList().size()) {
            for (Person p : personList) {
                if (!otherGroup.getPersonList().contains(p)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(information);
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getInformation());
        return builder.toString();
    }

}
```
###### \main\java\seedu\address\model\group\Information.java
``` java
package seedu.address.model.group;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.util.AppUtil.checkArgument;


/**
 * Represents a Group's information in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidInformation(String)}
 */
public class Information {

    public static final String MESSAGE_INFORMATION_CONSTRAINTS =
            "Group information should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the information must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String INFORMATION_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String value;

    /**
     * Constructs a {@code Information}.
     *
     * @param information A valid information.
     */
    public Information(String information) {
        requireNonNull(information);
        checkArgument(isValidInformation(information), MESSAGE_INFORMATION_CONSTRAINTS);
        this.value = information;
    }

    /**
     * Returns true if a given string is a valid to-do information.
     */
    public static boolean isValidInformation(String test) {
        return test.matches(INFORMATION_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Information // instanceof handles nulls
                && this.value.equals(((Information) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \main\java\seedu\address\model\group\MembersInGroupPredicate.java
``` java
package seedu.address.model.group;

import java.util.function.Predicate;

import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;

/**
 *Tests that a {@code Person}'s is in the group specified.
 */
public class MembersInGroupPredicate implements Predicate<Person> {

    private final Group group;

    public MembersInGroupPredicate(Group group) {
        this.group = group;
    }

    @Override
    public boolean test(Person person) {
        UniquePersonList personList = group.getPersonList();
        if (personList.contains(person)) {
            return true;
        }
        return false;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof MembersInGroupPredicate // instanceof handles nulls
                && this.group.equals(((MembersInGroupPredicate) other).group)); // state check
    }
}
```
###### \main\java\seedu\address\model\group\UniqueGroupList.java
``` java
package seedu.address.model.group;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.util.CollectionUtil.requireAllNonNull;

import java.util.Iterator;
import java.util.List;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;

/**
 * A list of Groups that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Group#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueGroupList implements Iterable<Group> {

    private final ObservableList<Group> internalList = FXCollections.observableArrayList();

    /**
     * Returns true if the list contains an equivalent Group as the given argument.
     */
    public boolean contains(Group toCheck) {
        requireNonNull(toCheck);
        return internalList.contains(toCheck);
    }

    /**
     * Adds a Group to the list.
     *
     * @throws DuplicateGroupException if the Group to add is a duplicate of an existing Group in the list.
     */
    public void add(Group toAdd) throws DuplicateGroupException {
        requireNonNull(toAdd);
        if (contains(toAdd)) {
            throw new DuplicateGroupException();
        }
        internalList.add(toAdd);
    }

    public void setGroups(UniqueGroupList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setGroups(List<Group> groups) throws DuplicateGroupException {
        requireAllNonNull(groups);
        final UniqueGroupList replacement = new UniqueGroupList();
        for (final Group group : groups) {
            replacement.add(group);
        }
        setGroups(replacement);
    }

    /**
     * Removes the equivalent Group from the list.
     *
     * @throws GroupNotFoundException if no such Group could be found in the list.
     */
    public boolean remove(Group toRemove) throws GroupNotFoundException {
        requireNonNull(toRemove);
        final boolean groupFoundAndDeleted = internalList.remove(toRemove);
        if (!groupFoundAndDeleted) {
            throw new GroupNotFoundException();
        }
        return groupFoundAndDeleted;
    }

    /**
     * Replaces the group {@code target} in the list with {@code editedGroup}.
     *
     * @throws DuplicateGroupException if the replacement is equivalent to another existing Group in the list.
     * @throws GroupNotFoundException if {@code target} could not be found in the list.
     */
    public void setGroup(Group target, Group editedGroup)
            throws DuplicateGroupException, GroupNotFoundException {
        requireNonNull(editedGroup);

        int index = internalList.indexOf(target);
        if (index == -1) {
            throw new GroupNotFoundException();
        }

        if (!target.equals(editedGroup) && internalList.contains(editedGroup)) {
            throw new DuplicateGroupException();
        }

        internalList.set(index, editedGroup);
    }

    /**
     * Returns the backing list as an unmodifiable {@code ObservableList}.
     */
    public ObservableList<Group> asObservableList() {
        return FXCollections.unmodifiableObservableList(internalList);
    }

    @Override
    public Iterator<Group> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueGroupList // instanceof handles nulls
                && this.internalList.equals(((UniqueGroupList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \main\java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteGroup(Group target) throws GroupNotFoundException {
        addressBook.removeGroup(target);
        indicateAddressBookChanged();
    }
```
###### \main\java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateGroup(Group target, Group editedGroup)
            throws DuplicateGroupException, GroupNotFoundException {
        requireAllNonNull(target, editedGroup);

        addressBook.updateGroup(target, editedGroup);
        indicateAddressBookChanged();
    }

    @Override
    public synchronized void addGroup(Group group) throws DuplicateGroupException {
        addressBook.addGroup(group);
        indicateAddressBookChanged();
    }

```
###### \main\java\seedu\address\model\person\TagContainKeywordsPredicate.java
``` java
package seedu.address.model.person;

import java.util.List;
import java.util.Set;
import java.util.function.Predicate;

import seedu.address.model.tag.Tag;

/**
 * Tests that a {@code Person}'s {@code Tag} matches any of the keywords given.
 */
public class TagContainKeywordsPredicate implements Predicate<Person> {
    private final List<String> keywords;

    public TagContainKeywordsPredicate(List<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public boolean test(Person person) {
        Set<Tag> tags = person.getTags();
        for (Tag t : tags) {
            for (String key : keywords) {
                if (t.name.equals(key)) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TagContainKeywordsPredicate // instanceof handles nulls
                && this.keywords.equals(((TagContainKeywordsPredicate) other).keywords)); // state check
    }
}
```
###### \main\java\seedu\address\storage\XmlAdaptedGroup.java
``` java
package seedu.address.storage;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import javax.xml.bind.annotation.XmlElement;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;

/**
 * JAXB-friendly version of the Group.
 */
public class XmlAdaptedGroup {

    public static final String MISSING_FIELD_MESSAGE_FORMAT = "Group's %s field is missing!";

    @XmlElement(required = true)
    private String information;

    @XmlElement(required = true)
    private List<XmlAdaptedPerson> personList = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedGroup.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedGroup() {
    }

    /**
     * Constructs an {@code XmlAdaptedGroup} with the given group details.
     */
    public XmlAdaptedGroup(String information) {
        this.information = information;
        this.personList = new ArrayList<>();
    }

    /**
     * Converts a given Group into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedGroup
     */
    public XmlAdaptedGroup(Group source) {
        information = source.getInformation().value;
        UniquePersonList persons = source.getPersonList();
        for (Person person : persons) {
            personList.add(new XmlAdaptedPerson(person));
        }
    }

    /**
     * Converts this jaxb-friendly adapted group object into the model's Group object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted group
     */
    public Group toModelType() throws IllegalValueException {
        if (this.information == null) {
            throw new IllegalValueException(String.format(MISSING_FIELD_MESSAGE_FORMAT,
                    Information.class.getSimpleName()));
        }
        if (!Information.isValidInformation(this.information)) {
            throw new IllegalValueException(Information.MESSAGE_INFORMATION_CONSTRAINTS);
        }
        final Information information = new Information(this.information);
        final UniquePersonList uniquePersonList = new UniquePersonList();
        for (XmlAdaptedPerson adaptedPerson : personList) {
            Person personToAdd = adaptedPerson.toModelType();
            uniquePersonList.add(personToAdd);
        }

        return new Group(information, uniquePersonList);

    }

    public List<XmlAdaptedPerson> getPersonList() {
        return personList;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (!(other instanceof XmlAdaptedGroup)) {
            return false;
        }

        XmlAdaptedGroup otherGroup = (XmlAdaptedGroup) other;
        return Objects.equals(information, otherGroup.information);
    }
}
```
###### \main\java\seedu\address\ui\GroupCard.java
``` java
package seedu.address.ui;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Region;
import seedu.address.model.group.Group;

/**
 * An UI component that displays information of a {@code Person}.
 */
public class GroupCard extends UiPart<Region> {

    private static final String FXML = "GroupListCard.fxml";

    public final Group group;

    @FXML
    private HBox cardPane;
    @FXML
    private Label information;
    @FXML
    private Label id;

    public GroupCard(Group group, int displayedIndex) {
        super(FXML);
        this.group = group;
        id.setText(displayedIndex + ". ");
        information.setText(group.getInformation().value);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        if (other == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(other instanceof GroupCard)) {
            return false;
        }

        // state check
        GroupCard card = (GroupCard) other;
        return id.getText().equals(card.id.getText())
                && group.equals(card.group);
    }
}
```
###### \main\java\seedu\address\ui\GroupListPanel.java
``` java
package seedu.address.ui;

import java.util.logging.Logger;

import org.fxmisc.easybind.EasyBind;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.Region;
import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.events.ui.GroupPanelSelectionChangedEvent;
import seedu.address.model.group.Group;

/**
 * Panel containing the list of groups.
 */
public class GroupListPanel extends UiPart<Region> {
    private static final String FXML = "GroupListPanel.fxml";
    private final Logger logger = LogsCenter.getLogger(GroupListPanel.class);

    @FXML
    private ListView<GroupCard> groupListView;

    public GroupListPanel(ObservableList<Group> groupList) {
        super(FXML);
        setConnections(groupList);
        registerAsAnEventHandler(this);
    }

    private void setConnections(ObservableList<Group> groupList) {
        ObservableList<GroupCard> mappedList = EasyBind.map(
                groupList, (group) -> new GroupCard(group, groupList.indexOf(group) + 1));
        groupListView.setItems(mappedList);
        groupListView.setCellFactory(listView -> new GroupListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void setEventHandlerForSelectionChangeEvent() {
        groupListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in group list panel changed to : '" + newValue + "'");
                        raise(new GroupPanelSelectionChangedEvent(newValue));
                    }
                });
    }

    /**
     * Custom {@code ListCell} that displays the graphics of a {@code GroupCard}.
     */
    class GroupListViewCell extends ListCell<GroupCard> {

        @Override
        protected void updateItem(GroupCard groupCard, boolean empty) {
            super.updateItem(groupCard, empty);

            if (empty || groupCard == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(groupCard.getRoot());
            }
        }

    }
}
```
###### \main\java\seedu\address\ui\MainWindow.java
``` java
        StatusBarFooter statusBarFooter = new StatusBarFooter(prefs.getAddressBookFilePath(),
                logic.getFilteredPersonList().size());
```
###### \main\java\seedu\address\ui\PersonCard.java
``` java
    private static final String[] TAG_COLOR_STYLES = AVAILABLE_COLORS;

    /**
     * Define tag colour styles
     */
    /**
     * Note: Certain keywords such as "location" and "resources" are reserved keywords in JavaFX.
     * As a consequence, UI elements' variable names cannot be set to such keywords
     * or an exception will be thrown by JavaFX during runtime.
     *
     * @see <a href="https://github.com/se-edu/addressbook-level4/issues/336">The issue on AddressBook level 4</a>
     */

    public final Person person;

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label phone;
    @FXML
    private Label address;
    @FXML
    private Label email;
    @FXML
    private Label detail;
    @FXML
    private FlowPane tags;

    public PersonCard(Person person, int displayedIndex) {
        super(FXML);
        this.person = person;
        id.setText(displayedIndex + ". ");
        name.setText(person.getName().fullName);
        phone.setText(person.getPhone().value);
        address.setText(person.getAddress().value);
        email.setText(person.getEmail().value);
        detail.setText(person.getDetail().detail);
        initTags(person);
    }

    /**
     * Returns the color style for {@code name}'s label.
     */
    private String getTagColorStyleFor(String tagName) {
        // use the hash code of the tag name to generate a random color, so that the color remain consistent
        // between different runs of the program while still making it random enough between tags.
        return TAG_COLOR_STYLES[Math.abs(tagName.hashCode()) % TAG_COLOR_STYLES.length - 1];
    }

    /**
     * Creates the tag labels for {@code person}.
     */
    private void initTags(Person person) {
        person.getTags().forEach(tag -> {
            Label tagLabel = new Label(tag.name);
            if (tag.color.equals("undefined")) {
                tagLabel.getStyleClass().add(getTagColorStyleFor(tag.name));
            } else {
                tagLabel.getStyleClass().add(tag.color);
            }
            tags.getChildren().add(tagLabel);
        });
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        if (other == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(other instanceof PersonCard)) {
            return false;
        }

        // state check
        PersonCard card = (PersonCard) other;
        return id.getText().equals(card.id.getText())
                && person.equals(card.person);
    }
}
```
###### \main\resources\view\GroupListCard.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <GridPane HBox.hgrow="ALWAYS">
        <columnConstraints>
            <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="100" />
        </columnConstraints>
        <VBox alignment="CENTER_LEFT" minHeight="70" GridPane.columnIndex="0">
            <padding>
                <Insets top="5" right="5" bottom="5" left="15" />
            </padding>
            <HBox spacing="5" alignment="CENTER_LEFT">
                <Label fx:id="id" styleClass="cell_big_label">
                    <minWidth>
                        <!-- Ensures that the label text is never truncated -->
                        <Region fx:constant="USE_PREF_SIZE" />
                    </minWidth>
                </Label>
                <Label fx:id="information" text="\$first" styleClass="cell_big_label" />
            </HBox>
        </VBox>
    </GridPane>
</HBox>
```
###### \main\resources\view\GroupListPanel.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<VBox xmlns="http://javafx.com/javafx/8.0.141" xmlns:fx="http://javafx.com/fxml/1">
   <Label  prefHeight="23.0" prefWidth="95.0" text="GROUP LIST" >
      <font>
         <Font name="System Bold" size="16.0" />
      </font></Label>
    <ListView fx:id="groupListView" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \main\resources\view\StatusBarFooter.fxml
``` fxml
  <StatusBar styleClass="anchor-pane" fx:id="totalPersonsStatus" GridPane.columnIndex="1" />
```
###### \test\java\guitests\guihandles\PersonCardHandle.java
``` java
    public List<String> getTagStyleClasses(String tag) {
        return tagLabels
                .stream()
                .filter(label -> label.getText().equals(tag))
                .map(Label::getStyleClass)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("No such tag."));
    }
}
```
###### \test\java\guitests\guihandles\StatusBarFooterHandle.java
``` java
    /**
     * Returns the text of the 'total persons' portion of the status bar.
     */
    public String getTotalPersonsStatus() {
        return totalPersonsStatusNode.getText();
    }
```
###### \test\java\guitests\guihandles\StatusBarFooterHandle.java
``` java
    /**
     * Remembers the content of the 'total persons' portion of the status bar.
     */
    public void rememberTotalPersonsStatus() {
        lastRememberedTotalPersonsStatus = getTotalPersonsStatus();
    }

    /**
     * Returns true if the current content of the 'total persons' is different from the value remembered by the most
     * recent {@code rememberTotalPersonsStatus()} call.
     */
    public boolean isTotalPersonsStatusChanged() {
        return !lastRememberedTotalPersonsStatus.equals(getTotalPersonsStatus());
    }
```
###### \test\java\seedu\address\logic\commands\AddGroupCommandIntegrationTest.java
``` java
package seedu.address.logic.commands;

import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.group.Group;
import seedu.address.testutil.GroupBuilder;

/**
 * Contains integration tests (interaction with the Model) for {@code AddGroupCommand}.
 */
public class AddGroupCommandIntegrationTest {

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void execute_newGroup_success() throws Exception {
        Group validGroup = new GroupBuilder().build();

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.addGroup(validGroup);

        assertCommandSuccess(prepareCommand(validGroup, model), model,
                String.format(AddGroupCommand.MESSAGE_SUCCESS, validGroup), expectedModel);
    }

    @Test
    public void execute_duplicateGroup_throwsCommandException() {
        Group groupInList = model.getAddressBook().getGroupList().get(0);
        assertCommandFailure(prepareCommand(groupInList, model), model, AddGroupCommand.MESSAGE_DUPLICATE_GROUP);
    }
    /**
     * Generates a new {@code AddGroupCommand} which upon execution, adds {@code group} into the {@code model}.
     */
    private AddGroupCommand prepareCommand(Group group, Model model) {
        AddGroupCommand command = new AddGroupCommand(group);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }
}
```
###### \test\java\seedu\address\logic\commands\AddGroupCommandTest.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.Predicate;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import javafx.collections.ObservableList;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.AddressBook;
import seedu.address.model.Model;
import seedu.address.model.ReadOnlyAddressBook;
import seedu.address.model.event.Event;
import seedu.address.model.event.exceptions.DuplicateEventException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.TagNotFoundException;
import seedu.address.model.todo.ToDo;
import seedu.address.model.todo.exceptions.DuplicateToDoException;
import seedu.address.model.todo.exceptions.ToDoNotFoundException;
import seedu.address.testutil.GroupBuilder;

public class AddGroupCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void constructor_nullGroup_throwsNullPointerException() {
        thrown.expect(NullPointerException.class);
        new AddGroupCommand(null);
    }

    @Test
    public void execute_groupAcceptedByModel_addSuccessful() throws Exception {
        ModelStubAcceptingGroupAdded modelStub = new ModelStubAcceptingGroupAdded();
        Group validGroup = new GroupBuilder().build();

        CommandResult commandResult = getAddGroupCommandForGroup(validGroup, modelStub).execute();

        assertEquals(String.format(AddGroupCommand.MESSAGE_SUCCESS, validGroup), commandResult.feedbackToUser);
        assertEquals(Arrays.asList(validGroup), modelStub.groupsAdded);
    }

    @Test
    public void execute_duplicateGroup_throwsCommandException() throws Exception {
        ModelStub modelStub = new ModelStubThrowingDuplicateGroupException();
        Group validGroup = new GroupBuilder().build();

        thrown.expect(CommandException.class);
        thrown.expectMessage(AddGroupCommand.MESSAGE_DUPLICATE_GROUP);

        getAddGroupCommandForGroup(validGroup, modelStub).execute();
    }

    @Test
    public void equals() {
        Group groupA = new GroupBuilder().withInformation("Group A").build();
        Group groupB = new GroupBuilder().withInformation("Group B").build();
        AddGroupCommand addGroupACommand = new AddGroupCommand(groupA);
        AddGroupCommand addGroupBCommand = new AddGroupCommand(groupB);

        // same object -> returns true
        assertTrue(addGroupACommand.equals(addGroupACommand));

        // same values -> returns true
        AddGroupCommand addGroupACommandCopy = new AddGroupCommand(groupA);
        assertTrue(addGroupACommand.equals(addGroupACommandCopy));

        // different types -> returns false
        assertFalse(addGroupACommand.equals(1));

        // null -> returns false
        assertFalse(addGroupACommand.equals(null));

        // different group -> returns false
        assertFalse(addGroupACommand.equals(addGroupBCommand));
    }

    /**
     * Generates a new AddGroupCommand with the details of the given group.
     */
    private AddGroupCommand getAddGroupCommandForGroup(Group group, Model model) {
        AddGroupCommand command = new AddGroupCommand(group);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

    /**
     * A default model stub that have all of the methods failing.
     */
    private class ModelStub implements Model {
        @Override
        public void addPerson(Person person) throws DuplicatePersonException {
            fail("This method should not be called.");
        }

        @Override
        public void addEvent(Event event) throws DuplicateEventException {
            fail("This method should not be called.");
        }

        @Override
        public void addToDo(ToDo todos) throws DuplicateToDoException {
            fail("This method should not be called.");
        }

        @Override
        public void addGroup(Group group) throws DuplicateGroupException {
            fail("This method should not be called.");
        }

        @Override
        public void updateTag(Tag target, Tag editedTag) throws TagNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void removeTag(Tag tag) {
            fail("This method should not be called.");
        }

        @Override
        public void resetData(ReadOnlyAddressBook newData
        ) {
            fail("This method should not be called.");
        }

        @Override
        public ReadOnlyAddressBook getAddressBook() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public void deletePerson(Person target) throws PersonNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void deleteToDo(ToDo target) throws ToDoNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void deleteGroup(Group target) throws GroupNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void updatePerson(Person target, Person editedPerson)
                throws DuplicatePersonException {
            fail("This method should not be called.");
        }

        @Override
        public void updateToDo(ToDo target, ToDo editedToDo)
                throws DuplicateToDoException {
            fail("This method should not be called.");
        }

        @Override
        public void updateGroup(Group target, Group editedGroup)
                throws DuplicateGroupException {
            fail("This method should not be called.");
        }

        @Override
        public ObservableList<Person> getFilteredPersonList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public ObservableList<ToDo> getFilteredToDoList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public ObservableList<Event> getFilteredEventList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public ObservableList<Group> getFilteredGroupList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public void updateFilteredPersonList(Predicate<Person> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredToDoList(Predicate<ToDo> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredEventList(Predicate<Event> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredGroupList(Predicate<Group> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void indicateCalendarChanged() {
            fail("This method should not be called.");
        }

        @Override
        public void indicateTimetableChanged() {
            fail("This method should not be called.");
        }

        @Override
        public boolean calendarIsViewed() {
            fail("This method should not be called.");
            return false;
        }

        @Override
        public void switchView() {
            fail("This method should not be called.");
        }
    }

    /**
     * A Model stub that always throw a DuplicateGroupException when trying to add a group.
     */
    private class ModelStubThrowingDuplicateGroupException extends ModelStub {
        @Override
        public void addGroup(Group group) throws DuplicateGroupException {
            throw new DuplicateGroupException();
        }

        @Override
        public ReadOnlyAddressBook getAddressBook() {
            return new AddressBook();
        }
    }

    /**
     * A Model stub that always accept the group being added.
     */
    private class ModelStubAcceptingGroupAdded extends ModelStub {
        final ArrayList<Group> groupsAdded = new ArrayList<>();

        @Override
        public void addGroup(Group group) throws DuplicateGroupException {
            requireNonNull(group);
            groupsAdded.add(group);
        }

        @Override
        public ReadOnlyAddressBook getAddressBook() {
            return new AddressBook();
        }
    }
}
```
###### \test\java\seedu\address\logic\commands\AddMemberToGroupCommandTest.java
``` java
package seedu.address.logic.commands;

import static java.util.Objects.requireNonNull;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST_PERSON;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import java.util.ArrayList;
import java.util.function.Predicate;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import javafx.collections.ObservableList;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.AddressBook;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.ReadOnlyAddressBook;
import seedu.address.model.UserPrefs;
import seedu.address.model.event.Event;
import seedu.address.model.event.exceptions.DuplicateEventException;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.model.group.exceptions.GroupNotFoundException;
import seedu.address.model.person.Person;
import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.TagNotFoundException;
import seedu.address.model.todo.ToDo;
import seedu.address.model.todo.exceptions.DuplicateToDoException;
import seedu.address.model.todo.exceptions.ToDoNotFoundException;
import seedu.address.testutil.GroupBuilder;
import seedu.address.testutil.TypicalPersons;

public class AddMemberToGroupCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void constructor_nullGroup_throwsNullPointerException() {
        thrown.expect(NullPointerException.class);
        new AddMemberToGroupCommand(null, null);
    }

    @Test
    public void execute_groupAcceptedByModel_addSuccessful() throws Exception {
        AddMemberToGroupCommandTest.ModelStubAcceptingGroupAdded modelStub = new
                AddMemberToGroupCommandTest.ModelStubAcceptingGroupAdded();
        Person person = modelStub.getFilteredPersonList().get(0);
        Group validGroup = getTypicalAddressBook().getGroupList().get(0);

        CommandResult commandResult = getAddMemberToGroupCommandForGroup(INDEX_FIRST_PERSON, validGroup,
                modelStub).execute();

        assertEquals(String.format(AddMemberToGroupCommand.MESSAGE_ADD_PERSON_TO_GROUP_SUCCESS,
                person.getName().toString(), validGroup.getInformation().toString()),
                commandResult.feedbackToUser);
    }

    @Test
    public void equals() {
        Group groupF = new GroupBuilder().withPerson("Group F", TypicalPersons.ALICE).build();
        Group groupG = new GroupBuilder().withPerson("Group G", TypicalPersons.BENSON).build();
        AddMemberToGroupCommand addMemberToGroupFCommand = new AddMemberToGroupCommand(INDEX_FIRST_PERSON, groupF);
        AddMemberToGroupCommand addMemberToGroupGCommand = new AddMemberToGroupCommand(INDEX_FIRST_PERSON, groupG);

        // same object -> returns true
        assertTrue(addMemberToGroupFCommand.equals(addMemberToGroupFCommand));

        // same values -> returns true
        AddMemberToGroupCommand addMemberToGroupCommand = new  AddMemberToGroupCommand(INDEX_FIRST_PERSON, groupF);
        assertTrue(addMemberToGroupFCommand.equals(addMemberToGroupCommand));

        // different types -> returns false
        assertFalse(addMemberToGroupFCommand.equals(1));

        // null -> returns false
        assertFalse(addMemberToGroupFCommand.equals(null));

        // different groups -> returns false
        assertFalse(addMemberToGroupFCommand.equals(addMemberToGroupGCommand));
    }

    /**
     * Generates a new AddMemberToGroupCommand with the details of the given to-do.
     */
    private AddMemberToGroupCommand getAddMemberToGroupCommandForGroup(Index index, Group group, Model model) {
        AddMemberToGroupCommand command = new AddMemberToGroupCommand(index, group);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

    /**
     * A default model stub that have all of the methods failing.
     */
    private class ModelStub implements Model {
        @Override
        public void addPerson(Person person) throws DuplicatePersonException {
            fail("This method should not be called.");
        }

        @Override
        public void addEvent(Event event) throws DuplicateEventException {
            fail("This method should not be called.");
        }

        @Override
        public void addToDo(ToDo todo) throws DuplicateToDoException {
            fail("This method should not be called.");
        }

        @Override
        public void addGroup(Group group) throws DuplicateGroupException {
            fail("This method should not be called.");
        }

        @Override
        public void updateTag(Tag target, Tag editedTag) throws TagNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void removeTag(Tag tag) {
            fail("This method should not be called.");
        }

        @Override
        public void resetData(ReadOnlyAddressBook newData
        ) {
            fail("This method should not be called.");
        }

        @Override
        public ReadOnlyAddressBook getAddressBook() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public void deletePerson(Person target) throws PersonNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void deleteToDo(ToDo target) throws ToDoNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void deleteGroup(Group target) throws GroupNotFoundException {
            fail("This method should not be called.");
        }


        @Override
        public void updatePerson(Person target, Person editedPerson)
                throws DuplicatePersonException {
            fail("This method should not be called.");
        }

        @Override
        public void updateToDo(ToDo target, ToDo editedToDo)
                throws DuplicateToDoException {
            fail("This method should not be called.");
        }

        @Override
        public void updateGroup(Group target, Group editedGroup)
                throws DuplicateGroupException {
        }

        @Override
        public ObservableList<Person> getFilteredPersonList() {
            return model.getFilteredPersonList();
        }

        @Override
        public ObservableList<ToDo> getFilteredToDoList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public ObservableList<Event> getFilteredEventList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public ObservableList<Group> getFilteredGroupList() {
            return model.getFilteredGroupList();
        }

        @Override
        public void updateFilteredPersonList(Predicate<Person> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredToDoList(Predicate<ToDo> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredEventList(Predicate<Event> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredGroupList(Predicate<Group> predicate) {
            fail("This method should not be called.");
        }

        @Override
        public void indicateCalendarChanged() {
            fail("This method should not be called.");
        }

        @Override
        public void indicateTimetableChanged() {
            fail("This method should not be called.");
        }

        @Override
        public boolean calendarIsViewed() {
            fail("This method should not be called.");
            return false;
        }

        @Override
        public void switchView() {
            fail("This method should not be called.");
        }
    }
    /**
     * A Model stub that always accept the to-do being added.
     */
    private class ModelStubAcceptingGroupAdded extends AddMemberToGroupCommandTest.ModelStub {
        final ArrayList<Group> groupsAdded = new ArrayList<>();

        @Override
        public void addGroup(Group group) throws DuplicateGroupException {
            requireNonNull(group);
            groupsAdded.add(group);
        }

        @Override
        public ReadOnlyAddressBook getAddressBook() {
            return new AddressBook();
        }
    }

}
```
###### \test\java\seedu\address\logic\commands\DeleteGroupCommandTest.java
``` java
package seedu.address.logic.commands;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.logic.commands.CommandTestUtil.prepareRedoCommand;
import static seedu.address.logic.commands.CommandTestUtil.prepareUndoCommand;
import static seedu.address.testutil.TypicalGroups.GROUP_A;
import static seedu.address.testutil.TypicalGroups.GROUP_B;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST_GROUP;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;

/**
 * Contains integration tests (interaction with the Model, UndoCommand and RedoCommand) and unit tests for
 * {@code DeleteGroupCommand}.
 */
public class DeleteGroupCommandTest {

    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs());

    @Test
    public void execute_validNameUnfilteredList_success() throws Exception {
        Group groupToDelete = model.getFilteredGroupList().get(INDEX_FIRST_GROUP.getZeroBased());
        DeleteGroupCommand deleteGroupCommand = prepareCommand(groupToDelete.getInformation());
        String expectedMessage = String.format(DeleteGroupCommand.MESSAGE_DELETE_GROUP_SUCCESS, groupToDelete);

        ModelManager expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.deleteGroup(groupToDelete);

        assertCommandSuccess(deleteGroupCommand, model, expectedMessage, expectedModel);
    }


    @Test
    public void executeUndoRedo_validNameUnfilteredList_success() throws Exception {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Group groupToDelete = model.getFilteredGroupList().get(INDEX_FIRST_GROUP.getZeroBased());
        DeleteGroupCommand deleteGroupCommand = prepareCommand(groupToDelete.getInformation());
        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());

        // delete -> first to-do deleted
        deleteGroupCommand.execute();
        undoRedoStack.push(deleteGroupCommand);

        // undo -> reverts addressbook back to previous state and filtered to-do list to show all to-dos
        assertCommandSuccess(undoCommand, model, UndoCommand.MESSAGE_SUCCESS, expectedModel);

        // redo -> same first to-do deleted again
        expectedModel.deleteGroup(groupToDelete);
        assertCommandSuccess(redoCommand, model, RedoCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void execute_invalidNameUnfilteredList_throwsCommandException() throws Exception {

        Information information = new Information("GROUP G");
        DeleteGroupCommand deleteGroupCommand = prepareCommand(information);

        assertCommandFailure(deleteGroupCommand, model, Messages.MESSAGE_INVALID_GROUP_NAME);
    }

    @Test
    public void executeUndoRedo_invalidNameUnfilteredList_failure() {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Information information = new Information("GROUP G");
        DeleteGroupCommand deleteGroupCommand = prepareCommand(information);

        // execution failed -> deleteGroupCommand not pushed into undoRedoStack
        assertCommandFailure(deleteGroupCommand, model, Messages.MESSAGE_INVALID_GROUP_NAME);

        // no commands in undoRedoStack -> undoCommand and redoCommand fail
        assertCommandFailure(undoCommand, model, UndoCommand.MESSAGE_FAILURE);
        assertCommandFailure(redoCommand, model, RedoCommand.MESSAGE_FAILURE);
    }

    @Test
    public void equals() throws Exception {
        DeleteGroupCommand deleteGroupFirstCommand = prepareCommand(GROUP_A.getInformation());
        DeleteGroupCommand deleteGroupSecondCommand = prepareCommand(GROUP_B.getInformation());

        // same object -> returns true
        assertTrue(deleteGroupFirstCommand.equals(deleteGroupFirstCommand));

        // same values -> returns true
        DeleteGroupCommand deleteGroupFirstCommandCopy = prepareCommand(GROUP_A.getInformation());
        assertTrue(deleteGroupFirstCommand.equals(deleteGroupFirstCommandCopy));

        // different types -> returns false
        assertFalse(deleteGroupFirstCommand.equals(1));

        // null -> returns false
        assertFalse(deleteGroupFirstCommand.equals(null));

        // different group -> returns false
        assertFalse(deleteGroupFirstCommand.equals(deleteGroupSecondCommand));
    }

    /**
     * Returns a {@code DeleteGroupCommand} with the parameter {@code index}.
     */
    private DeleteGroupCommand prepareCommand(Information information) {
        DeleteGroupCommand deleteGroupCommand = new DeleteGroupCommand(information);
        deleteGroupCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return deleteGroupCommand;
    }
}
```
###### \test\java\seedu\address\logic\commands\ListGroupMembersCommandTest.java
``` java
package seedu.address.logic.commands;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.MembersInGroupPredicate;

public class ListGroupMembersCommandTest {

    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs());

    @Test
    public void equals() {
        Group group1 = model.getFilteredGroupList().get(0);
        Group group2 = model.getFilteredGroupList().get(1);
        MembersInGroupPredicate firstPredicate =
                new MembersInGroupPredicate(group1);
        MembersInGroupPredicate secondPredicate =
                new MembersInGroupPredicate(group2);

        ListGroupMembersCommand findFirstCommand = new ListGroupMembersCommand(firstPredicate, group1);
        ListGroupMembersCommand findSecondCommand = new ListGroupMembersCommand(secondPredicate, group2);

        // same object -> returns true
        assertTrue(findFirstCommand.equals(findFirstCommand));

        // same values -> returns true
        ListGroupMembersCommand findFirstCommandCopy = new ListGroupMembersCommand(firstPredicate, group1);
        assertTrue(findFirstCommand.equals(findFirstCommandCopy));

        // different types -> returns false
        assertFalse(findFirstCommand.equals(1));

        // null -> returns false
        assertFalse(findFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(findFirstCommand.equals(findSecondCommand));
    }
    @Test
    public void execute_noGroupFound() {
        String expectedMessage = String.format(ListGroupMembersCommand.MESSAGE_NO_SUCH_GROUP);
        Group groupToList = new Group(new Information("Group Z"));
        MembersInGroupPredicate predicate = new MembersInGroupPredicate(groupToList);
        ListGroupMembersCommand command = prepareCommand(predicate, groupToList);
        assertCommandFailure(command, model, expectedMessage);
    }

    @Test
    public void execute_groupFoundSuccess() {

        Group groupToList = new Group(new Information("Group A"));
        String expectedMessage = String.format("0 persons listed!");
        Model expectedModel = model;
        MembersInGroupPredicate predicate = new MembersInGroupPredicate(groupToList);
        ListGroupMembersCommand command = prepareCommand(predicate, groupToList);
        assertCommandSuccess(command, model, expectedMessage, expectedModel);
    }

    /**
     * Parses {@code userInput} into a {@code ListGroupMembersCommand}.
     */
    private ListGroupMembersCommand prepareCommand(MembersInGroupPredicate predicate, Group groupToList) {
        ListGroupMembersCommand command =
                new ListGroupMembersCommand(new MembersInGroupPredicate(groupToList), groupToList);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }


}

```
###### \test\java\seedu\address\logic\commands\ListTagMembersCommandTest.java
``` java
package seedu.address.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.commons.core.Messages.MESSAGE_PERSONS_LISTED_OVERVIEW;
import static seedu.address.testutil.TypicalPersons.ALICE;
import static seedu.address.testutil.TypicalPersons.BENSON;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.AddressBook;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.person.Person;
import seedu.address.model.person.TagContainKeywordsPredicate;

/**
 * Contains integration tests (interaction with the Model) for {@code ListTagMembersCommand}.
 */
public class ListTagMembersCommandTest {
    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs());

    @Test
    public void equals() {
        TagContainKeywordsPredicate firstPredicate =
                new TagContainKeywordsPredicate(Collections.singletonList("first"));
        TagContainKeywordsPredicate secondPredicate =
                new TagContainKeywordsPredicate(Collections.singletonList("second"));

        ListTagMembersCommand findFirstCommand = new ListTagMembersCommand(firstPredicate);
        ListTagMembersCommand findSecondCommand = new ListTagMembersCommand(secondPredicate);

        // same object -> returns true
        assertTrue(findFirstCommand.equals(findFirstCommand));

        // same values -> returns true
        ListTagMembersCommand findFirstCommandCopy = new ListTagMembersCommand(firstPredicate);
        assertTrue(findFirstCommand.equals(findFirstCommandCopy));

        // different types -> returns false
        assertFalse(findFirstCommand.equals(1));

        // null -> returns false
        assertFalse(findFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(findFirstCommand.equals(findSecondCommand));
    }

    @Test
    public void execute_zeroKeywords_noPersonFound() {
        String expectedMessage = String.format(MESSAGE_PERSONS_LISTED_OVERVIEW, 0);
        ListTagMembersCommand command = prepareCommand(" ");
        assertCommandSuccess(command, expectedMessage, Collections.emptyList());
    }

    @Test
    public void execute_multipleKeywords_multiplePersonsFound() {
        String expectedMessage = String.format(MESSAGE_PERSONS_LISTED_OVERVIEW, 2);
        ListTagMembersCommand command = prepareCommand("CS3230 owesMoney");
        assertCommandSuccess(command, expectedMessage, Arrays.asList(ALICE, BENSON));
    }

    /**
     * Parses {@code userInput} into a {@code ListTagMembersCommand}.
     */
    private ListTagMembersCommand prepareCommand(String userInput) {
        ListTagMembersCommand command =
                new ListTagMembersCommand(new TagContainKeywordsPredicate(Arrays.asList(userInput.split("\\s+"))));
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

    /**
     * Asserts that {@code command} is successfully executed, and<br>
     *     - the command feedback is equal to {@code expectedMessage}<br>
     *     - the {@code FilteredList<Person>} is equal to {@code expectedList}<br>
     *     - the {@code AddressBook} in model remains the same after executing the {@code command}
     */
    private void assertCommandSuccess(ListTagMembersCommand command, String expectedMessage,
                                      List<Person> expectedList) {
        AddressBook expectedAddressBook = new AddressBook(model.getAddressBook());
        CommandResult commandResult = command.execute();

        assertEquals(expectedMessage, commandResult.feedbackToUser);
        assertEquals(expectedList, model.getFilteredPersonList());
        assertEquals(expectedAddressBook, model.getAddressBook());
    }
}
```
###### \test\java\seedu\address\logic\parser\AddGroupCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_INFORMATION;
import static seedu.address.logic.commands.CommandTestUtil.PREAMBLE_WHITESPACE;
import static seedu.address.logic.commands.CommandTestUtil.VALID_INFORMATION;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import org.junit.Test;

import seedu.address.logic.commands.AddGroupCommand;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.testutil.GroupBuilder;

public class AddGroupCommandParserTest {
    private AddGroupCommandParser parser = new AddGroupCommandParser();

    @Test
    public void parse_allFieldsPresent_success() {
        Group expectedGroup = new GroupBuilder().withInformation(VALID_INFORMATION).build();

        // whitespace only preamble
        assertParseSuccess(parser, PREAMBLE_WHITESPACE + VALID_INFORMATION,
                new AddGroupCommand(expectedGroup));

        // valid content
        assertParseSuccess(parser, VALID_INFORMATION,
                new AddGroupCommand(expectedGroup));
    }

    @Test
    public void parse_compulsoryFieldMissing_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddGroupCommand.MESSAGE_USAGE);

        // missing content
        assertParseFailure(parser, PREAMBLE_WHITESPACE,
                expectedMessage);
    }

    @Test
    public void parse_invalidValue_failure() {
        // invalid content
        assertParseFailure(parser, INVALID_INFORMATION,
                Information.MESSAGE_INFORMATION_CONSTRAINTS);
    }
}
```
###### \test\java\seedu\address\logic\parser\AddMemberToGroupCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_INDEX;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_INFORMATION;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_NO_GROUP;
import static seedu.address.logic.commands.CommandTestUtil.VALID_INFORMATION;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.ParserUtil.MESSAGE_INVALID_INDEX;

import org.junit.Test;

import seedu.address.logic.commands.AddMemberToGroupCommand;
import seedu.address.model.group.Information;


public class AddMemberToGroupCommandParserTest {

    private static final String MESSAGE_INVALID_FORMAT =
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddMemberToGroupCommand.MESSAGE_USAGE);

    private AddMemberToGroupCommandParser parser = new AddMemberToGroupCommandParser();

    @Test
    public void parse_missingParts_failure() {
        // no name of person specified
        assertParseFailure(parser, VALID_INFORMATION, MESSAGE_INVALID_FORMAT);


        // no  field specified
        assertParseFailure(parser, "", MESSAGE_INVALID_FORMAT);

    }

    @Test
    public void parse_compulsoryInvalidGroupField_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddMemberToGroupCommand.MESSAGE_USAGE);

        //missing group prefix
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_NO_GROUP, expectedMessage);

        //missing field
        assertParseFailure(parser , " ", expectedMessage);
    }

    @Test
    public void parse_indexNegative_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_INDEX);

        //negative index
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_INDEX, expectedMessage);
    }

    @Test
    public void parse_invalidInformation_failure() {
        String expectedMessage = String.format(Information.MESSAGE_INFORMATION_CONSTRAINTS);

        //wrong input for Group Information
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_INFORMATION, expectedMessage);

    }
}
```
###### \test\java\seedu\address\logic\parser\AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_addGroup() throws Exception {
        Group group = new GroupBuilder().build();
        AddGroupCommand command = (AddGroupCommand) parser.parseCommand(AddGroupCommand.COMMAND_WORD
                + " " + group.getInformation());
        assertEquals(new AddGroupCommand(group), command);
    }

    @Test
    public void parseCommand_addGroupAlias() throws Exception {
        Group group = new GroupBuilder().build();
        AddGroupCommand command = (AddGroupCommand) parser.parseCommand(AddGroupCommand.COMMAND_ALIAS
                + " " + group.getInformation());
        assertEquals(new AddGroupCommand(group), command);
    }

    @Test
    public void parseCommand_deleteGroup() throws Exception {
        Information information = new Information("Group A");
        DeleteGroupCommand command = (DeleteGroupCommand) parser.parseCommand(
                DeleteGroupCommand.COMMAND_WORD + " " + "Group A");
        assertEquals(new DeleteGroupCommand(information), command);
    }

    @Test
    public void parseCommand_deleteGroupAlias() throws Exception {
        Information information = new Information("Group A");
        DeleteGroupCommand command = (DeleteGroupCommand) parser.parseCommand(
                DeleteGroupCommand.COMMAND_ALIAS + " " + "Group A");
        assertEquals(new DeleteGroupCommand(information), command);
    }

```
###### \test\java\seedu\address\logic\parser\AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_listTagMembers() throws Exception {
        List<String> keywords = Arrays.asList("friends", "CS3230");
        ListTagMembersCommand command = (ListTagMembersCommand) parser.parseCommand(
                ListTagMembersCommand.COMMAND_WORD + " " + keywords.stream().collect(Collectors.joining(" ")));
        assertEquals(new ListTagMembersCommand(new TagContainKeywordsPredicate(keywords)), command);
    }

    @Test
    public void parseCommand_listTagGMembersAlias() throws Exception {
        List<String> keywords = Arrays.asList("friends", "CS3230");
        ListTagMembersCommand command = (ListTagMembersCommand) parser.parseCommand(
                ListTagMembersCommand.COMMAND_ALIAS + " " + keywords.stream().collect(Collectors.joining(" ")));
        assertEquals(new ListTagMembersCommand(new TagContainKeywordsPredicate(keywords)), command);
    }
```
###### \test\java\seedu\address\logic\parser\DeleteGroupCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalGroups.GROUP_A;

import org.junit.Test;

import seedu.address.logic.commands.DeleteGroupCommand;

/**
 * As we are only doing white-box testing, our test cases do not cover path variations
 * outside of the DeleteGroupCommand code. For example, inputs "GROUP A" take the
 * same path through the DeleteGroupCommand, and therefore we test only one of them.
 * The path variation for those two cases occur inside the ParserUtil, and
 * therefore should be covered by the ParserUtilTest.
 */
public class DeleteGroupCommandParserTest {

    private DeleteGroupCommandParser parser = new DeleteGroupCommandParser();

    @Test
    public void parse_validArgs_returnsDeleteGroupCommand() {
        assertParseSuccess(parser, "Group A", new DeleteGroupCommand(GROUP_A.getInformation()));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "!", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                DeleteGroupCommand.MESSAGE_USAGE));
    }
}
```
###### \test\java\seedu\address\logic\parser\DeleteMemberFromGroupCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_INDEX;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_INFORMATION;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_ADDGROUPMEMBER_NO_GROUP;
import static seedu.address.logic.commands.CommandTestUtil.VALID_INFORMATION;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.ParserUtil.MESSAGE_INVALID_INDEX;

import org.junit.Test;

import seedu.address.logic.commands.DeleteMemberFromGroupCommand;
import seedu.address.model.group.Information;


public class DeleteMemberFromGroupCommandParserTest {

    private static final String MESSAGE_INVALID_FORMAT =
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteMemberFromGroupCommand.MESSAGE_USAGE);

    private DeleteMemberFromGroupCommandParser parser = new DeleteMemberFromGroupCommandParser();

    @Test
    public void parse_missingParts_failure() {
        // no name of person specified
        assertParseFailure(parser, VALID_INFORMATION, MESSAGE_INVALID_FORMAT);


        // no  field specified
        assertParseFailure(parser, "", MESSAGE_INVALID_FORMAT);

    }

    @Test
    public void parse_compulsoryInvalidGroupField_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                DeleteMemberFromGroupCommand.MESSAGE_USAGE);

        //missing group prefix
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_NO_GROUP, expectedMessage);

        //missing field
        assertParseFailure(parser , " ", expectedMessage);
    }

    @Test
    public void parse_indexNegative_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_INDEX);

        //negative index
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_INDEX, expectedMessage);
    }

    @Test
    public void parse_invalidInformation_failure() {
        String expectedMessage = String.format(Information.MESSAGE_INFORMATION_CONSTRAINTS);

        //wrong input for Group Information
        assertParseFailure(parser, INVALID_ADDGROUPMEMBER_INFORMATION, expectedMessage);

    }
}
```
###### \test\java\seedu\address\logic\parser\ListGroupMembersCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import org.junit.Test;

import seedu.address.logic.commands.ListGroupMembersCommand;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.MembersInGroupPredicate;

public class ListGroupMembersCommandParserTest {
    private ListGroupMembersCommandParser parser = new ListGroupMembersCommandParser();


    @Test
    public void parse_emptyArg_throwsParseException() {
        assertParseFailure(parser, "", String.format(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                ListGroupMembersCommand.MESSAGE_USAGE)));
    }

    @Test
    public void parse_validArgs_returnsListGroupMembersCommand() {

        Group group = new Group(new Information("Group A"));
        ListGroupMembersCommand expectedListGroupMembersCommand =
                new ListGroupMembersCommand(new MembersInGroupPredicate(group), group);
        assertParseSuccess(parser, "Group A", expectedListGroupMembersCommand);

    }
    @Test
    public void parse_invalidArg_throwsParseException() {
        assertParseFailure(parser, "##!#@", String.format(Information.MESSAGE_INFORMATION_CONSTRAINTS));
    }
}
```
###### \test\java\seedu\address\logic\parser\ListTagMembersCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import java.util.Arrays;

import org.junit.Test;

import seedu.address.logic.commands.ListTagMembersCommand;
import seedu.address.model.person.TagContainKeywordsPredicate;

public class ListTagMembersCommandParserTest {

    private ListTagMembersCommandParser parser = new ListTagMembersCommandParser();

    @Test
    public void parse_emptyArg_throwsParseException() {
        assertParseFailure(parser, "     ", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                ListTagMembersCommand.MESSAGE_USAGE));
    }

    @Test
    public void parse_validArgs_returnsListTagMembersCommand() {
        // no leading and trailing whitespaces
        ListTagMembersCommand expectedListTagMembersCommand =
                new ListTagMembersCommand(new TagContainKeywordsPredicate(Arrays.asList("friends", "CS3230")));
        assertParseSuccess(parser, "friends CS3230", expectedListTagMembersCommand);

        // multiple whitespaces between keywords
        assertParseSuccess(parser, " \n friends \n \t CS3230  \t", expectedListTagMembersCommand);
    }

}
```
###### \test\java\seedu\address\model\AddressBookTest.java
``` java
    @Test
    public void resetData_withDuplicateGroups_throwsAssertionError() {
        // Repeat GROUP_A twice
        List<Person> newPersons = Arrays.asList(ALICE);
        List<Tag> newTags = new ArrayList<>(ALICE.getTags());
        List<ToDo> newToDos = Arrays.asList(TODO_A);
        List<Group> newGroups = Arrays.asList(GROUP_A, GROUP_A);
        List<Event> newEvents = Arrays.asList(F1RACE);
        AddressBookStub newData = new AddressBookStub(newPersons, newTags, newToDos, newGroups, newEvents);

        thrown.expect(AssertionError.class);
        addressBook.resetData(newData);
    }
```
###### \test\java\seedu\address\model\group\GroupTest.java
``` java
package seedu.address.model.group;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static seedu.address.testutil.TypicalPersons.ALICE;
import static seedu.address.testutil.TypicalPersons.BENSON;
import static seedu.address.testutil.TypicalPersons.CARL;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;
import seedu.address.testutil.GroupBuilder;

public class GroupTest {
```
###### \test\java\seedu\address\model\group\InformationTest.java
``` java
package seedu.address.model.group;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.VALID_CONTENT;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class InformationTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Information(null));
    }

    @Test
    public void constructor_invalidInformation_throwsIllegalArgumentException() {
        String invalidInformation = "!";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Information(invalidInformation));
    }

    @Test
    public void isValidInformation() {
        // null content
        Assert.assertThrows(NullPointerException.class, () -> Information.isValidInformation(null));

        // invalid content
        assertFalse(Information.isValidInformation("")); // empty string
        assertFalse(Information.isValidInformation(" ")); // spaces only
        assertFalse(Information.isValidInformation("^")); // only non-alphanumeric characters
        assertFalse(Information.isValidInformation("Something to do*")); // contains non-alphanumeric characters

        // valid content
        assertTrue(Information.isValidInformation("hello world")); // alphabets only
        assertTrue(Information.isValidInformation("12345")); // numbers only
        assertTrue(Information.isValidInformation("hello world the 2nd")); // alphanumeric characters
        assertTrue(Information.isValidInformation("Hello World")); // with capital letters
        assertTrue(Information.isValidInformation("David Roger Jackson Ray Jr 2nd")); // long names
    }

    @Test
    public void isSameInformationHashCode() {
        Information firstInformation = new Information(VALID_CONTENT);
        Information secondInformation = new Information(VALID_CONTENT);
        assertTrue(firstInformation.hashCode() == secondInformation.hashCode());
    }
}
```
###### \test\java\seedu\address\model\group\MembersInGroupPredicateTest.java
``` java
package seedu.address.model.group;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.model.person.Person;
import seedu.address.testutil.GroupBuilder;
import seedu.address.testutil.TypicalGroups;
import seedu.address.testutil.TypicalPersons;

public class MembersInGroupPredicateTest {

    private Group groupTest = TypicalGroups.GROUP_F;

    @Test
    public void test_groupDoesNotContainsMember_returnsFalse() {
        // Test Carl exist in group F
        MembersInGroupPredicate predicate = new MembersInGroupPredicate(groupTest);
        assertFalse(predicate.test(TypicalPersons.CARL));
    }

    @Test
    public void test_groupContainMember_returnTrue() {
        Group group = new GroupBuilder().withPerson("Group F",
                TypicalPersons.ALICE).build();
        Person personToTest = TypicalPersons.ALICE;
        MembersInGroupPredicate predicate = new MembersInGroupPredicate(group);
        assertTrue(predicate.test(personToTest));
    }
}
```
###### \test\java\seedu\address\model\person\TagContainKeywordsPredicateTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.PersonBuilder;

public class TagContainKeywordsPredicateTest {

    @Test
    public void equals() {
        List<String> firstPredicateKeywordList = Collections.singletonList("first");
        List<String> secondPredicateKeywordList = Arrays.asList("first", "second");

        TagContainKeywordsPredicate firstPredicate = new TagContainKeywordsPredicate(firstPredicateKeywordList);
        TagContainKeywordsPredicate secondPredicate = new TagContainKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        TagContainKeywordsPredicate firstPredicateCopy = new TagContainKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different person -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

    @Test
    public void test_tagContainKeywords_returnsTrue() {
        // One keyword
        TagContainKeywordsPredicate predicate = new TagContainKeywordsPredicate(Collections.singletonList("friends"));
        assertTrue(predicate.test(new PersonBuilder().withTags("friends").build()));

        // Only one matching keyword
        predicate = new TagContainKeywordsPredicate(Arrays.asList("friends", "Carol"));
        assertTrue(predicate.test(new PersonBuilder().withTags("friends").build()));

    }

    @Test
    public void test_tagDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        TagContainKeywordsPredicate predicate = new TagContainKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new PersonBuilder().withTags("friends").build()));

        // Non-matching keyword
        predicate = new TagContainKeywordsPredicate(Arrays.asList("friends"));
        assertFalse(predicate.test(new PersonBuilder().withTags("oweMoney").build()));

        // Mixed-case keywords
        predicate = new TagContainKeywordsPredicate(Arrays.asList("FrieNds"));
        assertFalse(predicate.test(new PersonBuilder().withTags("friends").build()));

    }
}
```
###### \test\java\seedu\address\model\UniqueGroupListTest.java
``` java
package seedu.address.model;

import static org.junit.Assert.assertEquals;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import seedu.address.model.group.UniqueGroupList;

public class UniqueGroupListTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void asObservableList_modifyList_throwsUnsupportedOperationException() {
        UniqueGroupList uniqueGroupList = new UniqueGroupList();
        thrown.expect(UnsupportedOperationException.class);
        uniqueGroupList.asObservableList().remove(0);
    }

    @Test
    public void hashCode_sameList_sameResult() throws Exception {
        UniqueGroupList uniqueGroupList1 = new UniqueGroupList();
        UniqueGroupList uniqueGroupList2 = new UniqueGroupList();
        assertEquals(uniqueGroupList1.hashCode(), uniqueGroupList2.hashCode());

    }
}
```
###### \test\java\seedu\address\storage\XmlAdaptedGroupTest.java
``` java
package seedu.address.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_INFORMATION;
import static seedu.address.storage.XmlAdaptedGroup.MISSING_FIELD_MESSAGE_FORMAT;
import static seedu.address.testutil.TypicalGroups.GROUP_A;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.group.Information;
import seedu.address.testutil.Assert;

public class XmlAdaptedGroupTest {

    @Test
    public void toModelType_validGroupDetails_returnsGroup() throws Exception {
        XmlAdaptedGroup group = new XmlAdaptedGroup(GROUP_A);
        assertEquals(GROUP_A, group.toModelType());
    }

    @Test
    public void toModelType_invalidInformation_throwsIllegalValueException() {
        XmlAdaptedGroup group =
                new XmlAdaptedGroup(INVALID_INFORMATION);
        String expectedMessage = Information.MESSAGE_INFORMATION_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, group::toModelType);
    }

    @Test
    public void toModelType_nullInformation_throwsIllegalValueException() {
        XmlAdaptedGroup group = new XmlAdaptedGroup((String) null);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Information.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, group::toModelType);
    }

    @Test
    public void equals() {
        XmlAdaptedGroup groupA = new XmlAdaptedGroup(GROUP_A);
        XmlAdaptedGroup groupB = new XmlAdaptedGroup(GROUP_A);
        assertTrue(groupA.equals(groupA));
        assertFalse(groupA.equals(1));
        assertTrue(groupA.equals(groupB));
    }

}
```
###### \test\java\seedu\address\testutil\GroupBuilder.java
``` java
package seedu.address.testutil;

import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.person.Person;
import seedu.address.model.person.UniquePersonList;
import seedu.address.model.person.exceptions.DuplicatePersonException;

/**
 * A utility class to help with building Group objects.
 */
public class GroupBuilder {

    public static final String DEFAULT_INFORMATION = "Something to do";

    private Information information;
    private UniquePersonList personList;

    public GroupBuilder() {
        information = new Information(DEFAULT_INFORMATION);
        personList = new UniquePersonList();
    }

    /**
     * Initializes the GroupBuilder with the data of {@code groupToCopy}.
     */
    public GroupBuilder(Group groupToCopy) {
        information = groupToCopy.getInformation();
        this.personList = groupToCopy.getPersonList();
    }

    /**
     * Sets the {@code Information} of the {@code Group} that we are building.
     */
    public GroupBuilder withInformation(String information) {
        this.information = new Information(information);
        personList = new UniquePersonList();
        return this;
    }

    /**
     * Sets the {@code Information} and {@code persons} of the {@code Group} that we are building.
     */
    public GroupBuilder withPerson(Person... personsToAdd) {
        this.information = new Information(DEFAULT_INFORMATION);
        personList = new UniquePersonList();
        try {
            for (Person person : personsToAdd) {
                personList.add(person);
            }
        } catch (DuplicatePersonException dpe) {
            throw new IllegalArgumentException("person is expected to be unique.");
        }
        return this;
    }

    /**
     * Sets the {@code Information} and {@code persons} of the {@code Group} that we are building.
     */
    public GroupBuilder withPerson(String information, Person... personsToAdd) {
        this.information = new Information(information);
        personList = new UniquePersonList();
        try {
            for (Person person : personsToAdd) {
                personList.add(person);
            }
        } catch (DuplicatePersonException dpe) {
            throw new IllegalArgumentException("person is expected to be unique.");
        }
        return this;
    }

    public Group build() {
        return new Group(information, personList);
    }

}
```
###### \test\java\seedu\address\testutil\GroupUtil.java
``` java
package seedu.address.testutil;

import seedu.address.logic.commands.AddGroupCommand;
import seedu.address.model.group.Group;
import seedu.address.model.person.UniquePersonList;

/**
 * A utility class for Group.
 */
public class GroupUtil {

    /**
     * Returns an addGroup command string for adding the {@code group}.
     */
    public static String getAddGroupCommand(Group group) {
        return AddGroupCommand.COMMAND_WORD + " " + getGroupDetails(group);
    }

    /**
     * Returns the part of command string for the given {@code group}'s details.
     */
    public static String getGroupDetails(Group group) {
        StringBuilder sb = new StringBuilder();
        sb.append(group.getInformation().value);
        return sb.toString();
    }
    /**
     * Returns the list of persons the given {@code group}
     */
    public static UniquePersonList getPersonList(Group group) {
        UniquePersonList personListToReturn = group.getPersonList();
        return personListToReturn;
    }

}
```
###### \test\java\seedu\address\testutil\TestUtil.java
``` java
    /**
     * Returns the group in the {@code model}'s group list at {@code index}.
     */
    public static Group getGroup(Model model, Index index) {
        return model.getAddressBook().getGroupList().get(index.getZeroBased());
    }
```
###### \test\java\seedu\address\testutil\TypicalGroups.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import seedu.address.model.group.Group;

/**
 * A utility class containing a list of {@code Group} objects to be used in tests.
 */
public class TypicalGroups {

    public static final Group GROUP_A = new GroupBuilder().withInformation("Group A").build();
    public static final Group GROUP_B = new GroupBuilder().withInformation("Group B").build();
    public static final Group GROUP_C = new GroupBuilder().withInformation("Group C").build();
    public static final Group GROUP_D = new GroupBuilder().withInformation("Group D").build();
    public static final Group GROUP_E = new GroupBuilder().withInformation("Group E").build();
    public static final Group GROUP_F = new GroupBuilder().withPerson("Group F",
            TypicalPersons.ALICE).build();
    public static final Group GROUP_G = new GroupBuilder().withPerson("Group G",
            TypicalPersons.BENSON).build();
    public static final Group GROUP_H = new GroupBuilder().withPerson("Group H", TypicalPersons.ALICE,
            TypicalPersons.BENSON).build();


    public static List<Group> getTypicalGroups() {
        return new ArrayList<>(Arrays.asList(GROUP_A, GROUP_B, GROUP_F, GROUP_H));
    }
}
```
###### \test\java\systemtests\AddGroupCommandSystemTest.java
``` java
package systemtests;

import static seedu.address.logic.commands.CommandTestUtil.INFORMATION_E;
import static seedu.address.testutil.TypicalGroups.GROUP_E;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.AddGroupCommand;
import seedu.address.model.Model;
import seedu.address.model.group.Group;
import seedu.address.model.group.exceptions.DuplicateGroupException;
import seedu.address.testutil.GroupUtil;

public class AddGroupCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void addGroup() throws Exception {
        /* ------------------------ Perform addGroup operations on the shown unfiltered list ---------------------- */

        /* Case: add a group to a non-empty address book, command with leading spaces and trailing spaces
         * -> added
         */
        Group addGroup = GROUP_E;
        String command = "   " + AddGroupCommand.COMMAND_WORD + "  " + INFORMATION_E + " ";
        assertCommandSuccess(command, addGroup);

        /* Case: invalid keyword -> rejected */
        command = "addsGroup " + GroupUtil.getGroupDetails(addGroup);
        assertCommandFailure(command,
                Messages.MESSAGE_UNKNOWN_COMMAND + Messages.MESSAGE_DID_YOU_MEAN + AddGroupCommand.COMMAND_WORD);

        /* Case: add a duplicate group -> rejected */
        command = GroupUtil.getAddGroupCommand(GROUP_E);
        assertCommandFailure(command, AddGroupCommand.MESSAGE_DUPLICATE_GROUP);
    }

    /**
     * Executes the {@code AddGroupCommand} that adds {@code addGroup} to the model and asserts that the,<br>
     * 1. Command node displays an empty string.<br>
     * 2. Command node has the default style class.<br>
     * 3. Result display node displays the success message of executing {@code AddGroupCommand} with the details of
     * {@code addGroup}.<br>
     * 4. {@code Model}, {@code Storage} and {@code PersonListPanel} equal to the corresponding components in
     * the current model added with {@code addGroup}.<br>
     * 5. Browser url and selected card remain unchanged.<br>
     * 6. Status bar's sync status changes.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(Group addGroup) {
        assertCommandSuccess(GroupUtil.getAddGroupCommand(addGroup), addGroup);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(Group)}. Executes {@code command}
     * instead.
     * @see AddGroupCommandSystemTest#assertCommandSuccess(Group)
     */
    private void assertCommandSuccess(String command, Group addGroup) {
        Model expectedModel = getModel();
        try {
            expectedModel.addGroup(addGroup);
        } catch (DuplicateGroupException dpt) {
            throw new IllegalArgumentException("addGroup already exists in the model.");
        }
        String expectedResultMessage = String.format(AddGroupCommand.MESSAGE_SUCCESS, addGroup);

        assertCommandSuccess(command, expectedModel, expectedResultMessage);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Group)} except asserts that
     * the,<br>
     * 1. Result display node displays {@code expectedResultMessage}.<br>
     * 2. {@code Model}, {@code Storage} and {@code GroupListPanel} equal to the corresponding components in
     * {@code expectedModel}.<br>
     * @see AddGroupCommandSystemTest#assertCommandSuccess(String, Group)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxAndResultDisplayShowsDefaultStyle();
        assertStatusBarChangedExceptSaveLocation();
    }

    /**
     * Executes {@code command} and asserts that the,<br>
     * 1. Command node displays {@code command}.<br>
     * 2. Command node has the error style class.<br>
     * 3. Result display node displays {@code expectedResultMessage}.<br>
     * 4. {@code Model}, {@code Storage} and {@code PersonListPanel} remain unchanged.<br>
     * 5. Browser url, selected card and status bar remain unchanged.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxAndResultDisplayShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### \test\java\systemtests\AddressBookSystemTest.java
``` java
    /**
     * Asserts that the sync status in the status bar was changed to the timing of
     * {@code ClockRule#getInjectedClock()}, and total persons was changed to match the total
     * number of persons in the address book, while the save location remains the same.
     */
    protected void assertStatusBarChangedExceptSaveLocation() {
        StatusBarFooterHandle handle = getStatusBarFooter();

        String timestamp = new Date(clockRule.getInjectedClock().millis()).toString();
        String expectedSyncStatus = String.format(SYNC_STATUS_UPDATED, timestamp);
        assertEquals(expectedSyncStatus, handle.getSyncStatus());

        final int totalPersons = testApp.getModel().getAddressBook().getPersonList().size();
        assertEquals(String.format(TOTAL_PERSONS_STATUS, totalPersons), handle.getTotalPersonsStatus());

        assertFalse(handle.isSaveLocationChanged());
    }
```
###### \test\java\systemtests\DeleteGroupCommandSystemTest.java
``` java
package systemtests;

import static seedu.address.commons.core.Messages.MESSAGE_DID_YOU_MEAN;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_GROUP_NAME;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.address.logic.commands.DeleteGroupCommand.MESSAGE_DELETE_GROUP_SUCCESS;
import static seedu.address.testutil.TestUtil.getGroup;
import static seedu.address.testutil.TestUtil.getLastIndexGroup;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST_GROUP;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.DeleteGroupCommand;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.model.Model;
import seedu.address.model.group.Group;
import seedu.address.model.group.Information;
import seedu.address.model.group.exceptions.GroupNotFoundException;

public class DeleteGroupCommandSystemTest extends AddressBookSystemTest {

    private static final String MESSAGE_INVALID_DELETE_GROUP_COMMAND_FORMAT =
            String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DeleteGroupCommand.MESSAGE_USAGE);

    @Test
    public void deleteGroup() {
        /* ----------------- Performing delete operation while an unfiltered list is being shown -------------------- */


        /* Case: delete the first group in the list, command with leading spaces and trailing spaces -> deleted */
        Model expectedModel = getModel();
        String command = "  " + DeleteGroupCommand.COMMAND_WORD + "  " + "Group A" + "  ";
        Group deletedGroup = removeGroup(expectedModel, INDEX_FIRST_GROUP);
        String expectedResultMessage = String.format(MESSAGE_DELETE_GROUP_SUCCESS,
                deletedGroup.getInformation().toString());
        assertCommandSuccess(command, expectedModel, expectedResultMessage);

        /* Case: delete the last group in the list -> deleted */
        Model modelBeforeDeletingLast = getModel();
        Index lastGroupIndex = getLastIndexGroup(modelBeforeDeletingLast);
        assertCommandSuccess(lastGroupIndex);

        /* Case: undo deleting the last group in the list -> last group restored */
        command = UndoCommand.COMMAND_WORD;
        expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);

        /* Case: redo deleting the last group in the list -> last group deleted again */
        command = RedoCommand.COMMAND_WORD;
        removeGroup(modelBeforeDeletingLast, lastGroupIndex);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);


        /* --------------------------------- Performing invalid delete operation ------------------------------------ */

        /* Case: invalid groupName (!) -> rejected */
        command = DeleteGroupCommand.COMMAND_WORD + " !";
        assertCommandFailure(command, MESSAGE_INVALID_DELETE_GROUP_COMMAND_FORMAT);

        /* Case: group Not in Fastis -> rejected */
        Information information = new Information("Group Z");
        command = DeleteGroupCommand.COMMAND_WORD + " " + information.toString();
        assertCommandFailure(command, MESSAGE_INVALID_GROUP_NAME);

        /* Case: invalid arguments (non - alphabets or numbers) -> rejected */
        assertCommandFailure(
                DeleteGroupCommand.COMMAND_WORD + " #@!@", MESSAGE_INVALID_DELETE_GROUP_COMMAND_FORMAT);


        /* Case: mixed case command word -> rejected */
        assertCommandFailure("DelETEGroup Group A",
                MESSAGE_UNKNOWN_COMMAND + MESSAGE_DID_YOU_MEAN + DeleteGroupCommand.COMMAND_WORD);
    }

    /**
     * Removes the {@code Group} at the specified {@code index} in {@code model}'s address book.
     * @return the removed group
     */
    private Group removeGroup(Model model, Index index) {
        Group targetGroup = getGroup(model, index);
        try {
            model.deleteGroup(targetGroup);
        } catch (GroupNotFoundException tnfe) {
            throw new AssertionError("targetGroup is retrieved from model.");
        }

        return targetGroup;
    }

    /**
     * Deletes the group at {@code toDelete} by creating a default {@code DeleteGroupCommand} using {@code toDelete} and
     * performs the same verification as {@code assertCommandSuccess(String, Model, String)}.
     * @see DeleteGroupCommandSystemTest#assertCommandSuccess(String, Model, String)
     */
    private void assertCommandSuccess(Index toDelete) {
        Model expectedModel = getModel();

        Group deletedGroup = removeGroup(expectedModel, toDelete);
        String expectedResultMessage = String.format(MESSAGE_DELETE_GROUP_SUCCESS,
                deletedGroup.getInformation().toString());
        assertCommandSuccess(DeleteGroupCommand.COMMAND_WORD + " "
                        + "Group H", expectedModel, expectedResultMessage);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card remains unchanged.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String)} except that the browser url
     * and selected card are expected to update accordingly depending on the card at {@code expectedSelectedCardIndex}.
     * @see DeleteCommandSystemTest#assertCommandSuccess(String, Model, String)
     * @see AddressBookSystemTest#assertSelectedCardChanged(Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage,
                                      Index expectedSelectedCardIndex) {
        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);

        if (expectedSelectedCardIndex != null) {
            assertSelectedCardChanged(expectedSelectedCardIndex);
        } else {
            assertSelectedCardUnchanged();
        }

        assertCommandBoxAndResultDisplayShowsDefaultStyle();
        assertStatusBarChangedExceptSaveLocation();
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays {@code command}.<br>
     * 2. Asserts that result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to the current model.<br>
     * 4. Asserts that the browser url, selected card and status bar remain unchanged.<br>
     * 5. Asserts that the command box has the error style.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxAndResultDisplayShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
